---
import Layout from '../layouts/Layout.astro';
import { getCollection } from 'astro:content';
import { t } from '../utils/i18n';

const allPosts = await getCollection('posts');

// Helper function to resolve multilingual frontmatter
function resolveMultilingualData(data: any, lang: 'en' | 'it') {
  const resolved = { ...data };
  Object.keys(resolved).forEach(key => {
    const value = resolved[key];
    if (typeof value === 'object' && value !== null && !Array.isArray(value) && !value.lat) {
      if (value[lang]) {
        resolved[key] = value[lang];
      } else if (value.en) {
        resolved[key] = value.en; // Fallback to English
      }
    } else if (Array.isArray(value)) {
      resolved[key] = value.map((item: any) => {
        if (item.name && typeof item.name === 'object') {
          if (item.name[lang]) {
            return { ...item, name: item.name[lang] };
          } else if (item.name.en) {
            return { ...item, name: item.name.en };
          }
        }
        return item;
      });
    }
  });
  return resolved;
}

// Process posts for both languages
const processedPostsEn = allPosts.map(post => {
  const resolvedData = resolveMultilingualData(post.data, 'en');
  return { ...post, data: resolvedData, lang: 'en' };
});

const processedPostsIt = allPosts.map(post => {
  const resolvedData = resolveMultilingualData(post.data, 'it');
  return { ...post, data: resolvedData, lang: 'it' };
});

// Filter posts with coordinates for both languages
const postsWithCoordsEn = processedPostsEn
  .filter(post => {
    const hasCoords = post.data.coords && post.data.coords.lat && post.data.coords.lon;
    const hasLocations = post.data.locations && post.data.locations.length > 0;
    return hasCoords || hasLocations;
  })
  .map(post => {
    let mainCoords = null;
    if (post.data.locations && post.data.locations.length > 0) {
      const mainLocation = post.data.locations.find(loc => loc.isMain) || post.data.locations[0];
      mainCoords = mainLocation.coords;
    } else if (post.data.coords) {
      mainCoords = post.data.coords;
    }
    return { ...post, mainCoords };
  })
  .sort((a, b) => new Date(b.data.publishTime).getTime() - new Date(a.data.publishTime).getTime());

const postsWithCoordsIt = processedPostsIt
  .filter(post => {
    const hasCoords = post.data.coords && post.data.coords.lat && post.data.coords.lon;
    const hasLocations = post.data.locations && post.data.locations.length > 0;
    return hasCoords || hasLocations;
  })
  .map(post => {
    let mainCoords = null;
    if (post.data.locations && post.data.locations.length > 0) {
      const mainLocation = post.data.locations.find(loc => loc.isMain) || post.data.locations[0];
      mainCoords = mainLocation.coords;
    } else if (post.data.coords) {
      mainCoords = post.data.coords;
    }
    return { ...post, mainCoords };
  })
  .sort((a, b) => new Date(b.data.publishTime).getTime() - new Date(a.data.publishTime).getTime());

const postsWithCoords = postsWithCoordsEn
  .filter(post => {
    // Check if post has coords or has locations
    const hasCoords = post.data.coords && post.data.coords.lat && post.data.coords.lon;
    const hasLocations = post.data.locations && post.data.locations.length > 0;
    return hasCoords || hasLocations;
  })
  .map(post => {
    // Get main location coordinates for map display
    let mainCoords = null;
    if (post.data.locations && post.data.locations.length > 0) {
      const mainLocation = post.data.locations.find(loc => loc.isMain) || post.data.locations[0];
      mainCoords = mainLocation.coords;
    } else if (post.data.coords) {
      mainCoords = post.data.coords;
    }
    return { ...post, mainCoords };
  })
  .sort((a, b) => new Date(b.data.publishTime).getTime() - new Date(a.data.publishTime).getTime());
---

<Layout>
  <!-- English Version -->
  <div data-lang="en">
    {postsWithCoordsEn.length > 0 ? (
      <div class="w-full h-screen">
        <div id="global-map-en" class="w-full h-full relative">
        </div>
      </div>
    ) : (
      <div class="w-full h-screen flex items-center justify-center">
        <div class="text-center">
          <div class="text-6xl mb-4">üó∫Ô∏è</div>
          <p class="text-gray-500 dark:text-gray-400 text-lg">
            No georeferenced places yet. The first journeys will arrive soon.
          </p>
        </div>
      </div>
    )}
  </div>

  <!-- Italian Version -->
  <div data-lang="it" style="display: none;">
    {postsWithCoordsIt.length > 0 ? (
      <div class="w-full h-screen">
        <div id="global-map-it" class="w-full h-full relative">
        </div>
      </div>
    ) : (
      <div class="w-full h-screen flex items-center justify-center">
        <div class="text-center">
          <div class="text-6xl mb-4">üó∫Ô∏è</div>
          <p class="text-gray-500 dark:text-gray-400 text-lg">
            Nessun luogo geolocalizzato ancora. I primi viaggi arriveranno presto.
          </p>
        </div>
      </div>
    )}
  </div>

  {(postsWithCoordsEn.length > 0 || postsWithCoordsIt.length > 0) && (
    <>
      <link rel="stylesheet" href="/libs/leaflet/leaflet.css" is:inline />
      <script src="/libs/leaflet/leaflet.js" is:inline></script>
      
      <style>
        /* Light theme popup styles */
        .leaflet-popup-content-wrapper {
          background: white;
          color: #1f2937;
          border-radius: 8px;
          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }
        
        .leaflet-popup-tip {
          background: white;
        }
        
        /* Dark theme popup styles */
        .dark .leaflet-popup-content-wrapper {
          background: #374151 !important;
          color: #f3f4f6 !important;
        }
        
        .dark .leaflet-popup-tip {
          background: #374151 !important;
        }
        
        .dark .leaflet-popup-close-button {
          color: #f3f4f6 !important;
        }
        
        .dark .leaflet-popup-close-button:hover {
          color: #d1d5db !important;
        }
        
        /* Improve text contrast in popups */
        .leaflet-popup-content .text-gray-600 {
          color: #4b5563 !important;
        }
        
        .dark .leaflet-popup-content .text-gray-600 {
          color: #d1d5db !important;
        }
        
        /* Modern zoom controls styling */
        .leaflet-control-zoom {
          border: none !important;
          box-shadow: none !important;
        }
        
        .leaflet-control-zoom {
          border: none !important;
          box-shadow: none !important;
        }
        
        .leaflet-top.leaflet-left {
          top: 80px !important;
          left: 20px !important;
          position: fixed !important;
          z-index: 1000 !important;
        }
        
        @media (max-width: 640px) {
          .leaflet-top.leaflet-left {
            display: none !important;
          }
          
          .leaflet-bottom.leaflet-left {
            bottom: 20px !important;
            left: 20px !important;
            position: fixed !important;
            z-index: 1000 !important;
          }
          
          .leaflet-control-zoom {
            display: flex !important;
            flex-direction: row !important;
            position: relative !important;
          }
          
          .leaflet-control-zoom a {
            margin: 0 6px !important;
            width: 44px !important;
            height: 44px !important;
            line-height: 42px !important;
            font-size: 20px !important;
          }
        }
        
        .leaflet-control-zoom a {
          background: white !important;
          color: #374151 !important;
          border: none !important;
          border-radius: 8px !important;
          margin: 4px !important;
          width: 40px !important;
          height: 40px !important;
          line-height: 38px !important;
          font-size: 18px !important;
          font-weight: 600 !important;
          text-decoration: none !important;
          box-shadow: 0 2px 8px rgba(0,0,0,0.15) !important;
          transition: all 0.2s ease !important;
        }
        
        .leaflet-control-zoom a:hover {
          background: #f3f4f6 !important;
          color: #1f2937 !important;
          transform: scale(1.05) !important;
        }
        
        .leaflet-control-zoom a.leaflet-disabled {
          background: #f9fafb !important;
          color: #d1d5db !important;
        }
        
        /* Dark theme zoom controls */
        .dark .leaflet-control-zoom {
          box-shadow: none !important;
        }
        
        .dark .leaflet-control-zoom a {
          background: #374151 !important;
          color: #f3f4f6 !important;
        }
        
        .dark .leaflet-control-zoom a:hover {
          background: #4b5563 !important;
          color: #ffffff !important;
        }
        
        .dark .leaflet-control-zoom a.leaflet-disabled {
          background: #1f2937 !important;
          color: #6b7280 !important;
        }
        
        /* Hide attribution */
        .leaflet-control-attribution {
          display: none !important;
        }
        
        /* Fix z-index to not overlap navbar */
        .leaflet-container {
          z-index: 1 !important;
        }
        
        /* Lighten dark theme tiles */
        .dark .leaflet-tile {
          filter: brightness(1.4) contrast(0.8) saturate(0.9) !important;
        }
        
        /* Also apply filter to the entire map container in dark mode */
        .dark #global-map {
          filter: brightness(1.1) !important;
        }
        
        /* Hide entire map div initially to prevent flash of wrong position */
        #global-map-en,
        #global-map-it {
          opacity: 0;
          transition: opacity 0.5s ease-in;
        }
        
        /* Show map after positioning is complete */
        #global-map-en.map-ready,
        #global-map-it.map-ready {
          opacity: 1;
        }
      </style>
      
      <script define:vars={{ postsWithCoordsEn, postsWithCoordsIt }}>
        // Shared helper functions (inlined for Astro compatibility)
        function createMapIcons() {
          const lightIcon = L.divIcon({
            className: 'custom-marker light-marker',
            html: `
              <div style="
                width: 18px; 
                height: 18px; 
                background: #dc2626; 
                border: 2px solid white; 
                border-radius: 50%; 
                box-shadow: 0 2px 8px rgba(0,0,0,0.3);
              ">
              </div>
            `,
            iconSize: [18, 18],
            iconAnchor: [9, 9]
          });

          const darkIcon = L.divIcon({
            className: 'custom-marker dark-marker',
            html: `
              <div style="
                width: 18px; 
                height: 18px; 
                background: #e5e7eb; 
                border: 2px solid #374151; 
                border-radius: 50%; 
                box-shadow: 0 2px 8px rgba(0,0,0,0.4);
              ">
              </div>
            `,
            iconSize: [18, 18],
            iconAnchor: [9, 9]
          });

          return { lightIcon, darkIcon };
        }

        function createTileLayers() {
          const lightTiles = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
            attribution: '¬© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors ¬© <a href="https://carto.com/attributions">CARTO</a>'
          });
          
          const darkTiles = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
            attribution: '¬© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors ¬© <a href="https://carto.com/attributions">CARTO</a>'
          });
          
          return { lightTiles, darkTiles };
        }

        function setupMapTheme(map, lightTiles, darkTiles) {
          function updateMapTheme() {
            const isDark = document.documentElement.classList.contains('dark');
            if (isDark) {
              map.removeLayer(lightTiles);
              darkTiles.addTo(map);
            } else {
              map.removeLayer(darkTiles);
              lightTiles.addTo(map);
            }
          }
          
          // Set initial theme
          updateMapTheme();
          
          // Listen for theme changes
          const observer = new MutationObserver(updateMapTheme);
          observer.observe(document.documentElement, {
            attributes: true,
            attributeFilter: ['class']
          });
          
          return updateMapTheme;
        }

        let mapEn, mapIt;
        
        // Expose maps globally so Layout.astro can access them
        window.mapEn = null;
        window.mapIt = null;

        function initializeMap() {
          if (typeof L === 'undefined') {
            setTimeout(initializeMap, 100);
            return;
          }

          // Process posts for both languages
          const postsEn = postsWithCoordsEn.map(post => ({
            title: post.data.title,
            slug: post.slug.replace('en/', '').replace('it/', ''),
            coords: post.mainCoords,
            dateStart: post.data.eventStartTime,
            dateEnd: post.data.eventEndTime,
            cover: post.data.cover
          }));

          const postsIt = postsWithCoordsIt.map(post => ({
            title: post.data.title,
            slug: post.slug.replace('en/', '').replace('it/', ''),
            coords: post.mainCoords,
            dateStart: post.data.eventStartTime,
            dateEnd: post.data.eventEndTime,
            cover: post.data.cover
          }));

          // Initialize English map
          if (postsEn.length > 0) {
            // Delay map creation slightly to ensure DOM is ready
            setTimeout(() => {
              // Calculate bounds and center
              const bounds = L.latLngBounds(postsEn.map(post => [post.coords.lat, post.coords.lon]));
              const center = bounds.getCenter();
              
              mapEn = L.map('global-map-en', {
                zoomControl: false
              }).setView([center.lat, center.lng], 10);
              
              // Expose to global scope for language switching
              window.mapEn = mapEn;
              
              setupMapContent(mapEn, postsEn, 'en');
            }, 100);
          }

          // Initialize Italian map  
          if (postsIt.length > 0) {
            // Delay map creation slightly to ensure DOM is ready
            setTimeout(() => {
              // Calculate bounds and center
              const bounds = L.latLngBounds(postsIt.map(post => [post.coords.lat, post.coords.lon]));
              const center = bounds.getCenter();

              mapIt = L.map('global-map-it', {
                zoomControl: false
              }).setView([center.lat, center.lng], 10);
              
              // Expose to global scope for language switching
              window.mapIt = mapIt;
              
              setupMapContent(mapIt, postsIt, 'it');
            }, 100);
          }
        }

        function setupMapContent(map, posts, lang) {
          // Helper function to format date ranges
          function formatDateRange(startDate, endDate, locale) {
            const start = new Date(startDate);
            const end = new Date(endDate);

            const sameMonth = start.getMonth() === end.getMonth() && start.getFullYear() === end.getFullYear();

            if (sameMonth) {
              const day1 = start.getDate();
              const day2 = end.getDate();

              if (day1 === day2) {
                return start.toLocaleDateString(locale, {
                  day: 'numeric',
                  month: 'long',
                  year: 'numeric'
                });
              }

              const month = start.toLocaleDateString(locale, { month: 'long' });
              const year = start.getFullYear();
              return `${day1}-${day2} ${month} ${year}`;
            } else {
              const startStr = start.toLocaleDateString(locale, {
                day: 'numeric',
                month: 'long'
              });
              const endStr = end.toLocaleDateString(locale, {
                day: 'numeric',
                month: 'long'
              });
              const year = end.getFullYear();

              if (start.getFullYear() === end.getFullYear()) {
                return `${startStr} - ${endStr} ${year}`;
              } else {
                const startWithYear = start.toLocaleDateString(locale, {
                  day: 'numeric',
                  month: 'long',
                  year: 'numeric'
                });
                const endWithYear = end.toLocaleDateString(locale, {
                  day: 'numeric',
                  month: 'long',
                  year: 'numeric'
                });
                return `${startWithYear} - ${endWithYear}`;
              }
            }
          }

          // Get the correct map container ID
          const mapContainerId = lang === 'en' ? 'global-map-en' : 'global-map-it';
          // Add zoom control
          const isMobile = window.innerWidth <= 640;
          L.control.zoom({
            position: isMobile ? 'bottomleft' : 'topleft'
          }).addTo(map);

          // Create tile layers and setup theme
          const { lightTiles, darkTiles } = createTileLayers();
          setupMapTheme(map, lightTiles, darkTiles);

          // Create marker icons
          const { lightIcon, darkIcon } = createMapIcons();
          const markers = [];

          // Add markers
          posts.forEach((post) => {
            const isDark = document.documentElement.classList.contains('dark');
            const icon = isDark ? darkIcon : lightIcon;
            const marker = L.marker([post.coords.lat, post.coords.lon], { icon: icon }).addTo(map);

            const dateLocale = lang === 'it' ? 'it-IT' : 'en-US';
            const readMoreText = lang === 'it' ? 'Leggi di pi√π ‚Üí' : 'Read more ‚Üí';
            const dateRangeStr = formatDateRange(post.dateStart, post.dateEnd, dateLocale);

            const popupContent = `
              <div class="p-1 sm:p-2 w-full">
                ${post.cover ? `<img src="${post.cover}" alt="${post.title}" class="w-full h-16 sm:h-20 object-cover rounded mb-1 sm:mb-2">` : ''}
                <h3 class="font-semibold text-xs sm:text-sm mb-1 leading-tight">${post.title}</h3>
                <p class="text-xs text-gray-600 mb-1 sm:mb-2">${dateRangeStr}</p>
                <a href="/posts/${post.slug}/" class="inline-block text-xs text-blue-600 hover:text-blue-800 font-medium">${readMoreText}</a>
              </div>
            `;

            marker.bindPopup(popupContent);
            markers.push(marker);
          });

          // Adjust map view for all locations (like in GeoMap)
          if (markers.length > 0) {
            const group = new L.featureGroup(markers);
            map.fitBounds(group.getBounds().pad(0.1));
          }
          
          // Show map after positioning is complete
          setTimeout(() => {
            // Show the map by adding class to the correct map div
            const mapDiv = document.getElementById(mapContainerId);
            if (mapDiv) {
              mapDiv.classList.add('map-ready');
            }
          }, 400);
          
          // Fallback to show map after longer delay
          setTimeout(() => {
            const mapDiv = document.getElementById(mapContainerId);
            if (mapDiv && !mapDiv.classList.contains('map-ready')) {
              mapDiv.classList.add('map-ready');
            }
          }, 1000);
        }
        
        // Try multiple loading strategies
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', initializeMap);
        } else {
          initializeMap();
        }
        
        // Fallback
        window.addEventListener('load', initializeMap);
      </script>
    </>
  )}
</Layout>