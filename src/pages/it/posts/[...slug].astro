---
import { getCollection } from 'astro:content';
import PostLayout from '../../../layouts/PostLayout.astro';
import { parseMultilingualMarkdown, extractLanguageContent } from '../../../utils/multilingualMarkdown';
import type { Language } from '../../../utils/translations';
import { marked } from 'marked';

export async function getStaticPaths() {
  const allPosts = await getCollection('posts');
  
  // Handle both old format (it/ prefix) and new format (multilingual files)
  const paths: any[] = [];
  
  for (const post of allPosts) {
    if (post.slug.startsWith('it/')) {
      // Old format - Italian posts with it/ prefix
      paths.push({
        params: { slug: post.slug.replace('it/', '') },
        props: { ...post, lang: 'it' as Language },
      });
    } else if (!post.slug.startsWith('en/')) {
      // New format - multilingual files without language prefix
      try {
        // Try to parse as multilingual content
        const rawContent = post.body;
        if (rawContent.includes('<!-- en -->') || rawContent.includes('<!-- it -->')) {
          // This is a multilingual file - extract Italian content
          const sections = rawContent.split(/<!--\s*it\s*-->/);
          let itContent = '';
          if (sections.length > 1) {
            const afterItMarker = sections[1];
            const beforeEnMarker = afterItMarker.split(/<!--\s*en\s*-->/)[0];
            itContent = beforeEnMarker.trim();
          }
          
          // Resolve multilingual frontmatter fields for Italian
          const resolvedData = { ...post.data };
          Object.keys(resolvedData).forEach(key => {
            const value = resolvedData[key];
            if (typeof value === 'object' && value !== null && !Array.isArray(value) && !value.lat) {
              if (value.it) {
                resolvedData[key] = value.it;
              } else if (value.en) {
                resolvedData[key] = value.en; // Fallback to English
              }
            } else if (Array.isArray(value)) {
              resolvedData[key] = value.map(item => {
                if (item.name && typeof item.name === 'object') {
                  if (item.name.it) {
                    return { ...item, name: item.name.it };
                  } else if (item.name.en) {
                    return { ...item, name: item.name.en };
                  }
                }
                return item;
              });
            }
          });
          resolvedData.lang = 'it';
          
          paths.push({
            params: { slug: post.slug },
            props: { 
              ...post, 
              data: resolvedData,
              content: itContent,
              lang: 'it' as Language 
            },
          });
        } else {
          // Regular single-language file - skip for Italian route
          // (single-language files are assumed to be English)
        }
      } catch (error) {
        // Fallback - skip if parsing fails
      }
    }
  }
  
  return paths;
}

const post = Astro.props;
let Content, processedData, processedMarkdown;

if (post.content) {
  // Multilingual content - process markdown to HTML
  processedData = post.data;
  processedMarkdown = marked(post.content);
  Content = null;
} else {
  // Regular content
  const rendered = await post.render();
  Content = rendered.Content;
  processedData = post.data;
  processedMarkdown = null;
}

// Resolve multilingual fields
const resolvedData = { ...processedData };
Object.keys(resolvedData).forEach(key => {
  const value = resolvedData[key];
  if (typeof value === 'object' && value !== null && !Array.isArray(value) && !value.lat) {
    if (value.it) {
      resolvedData[key] = value.it;
    } else if (value.en) {
      // Fallback to English if Italian not available
      resolvedData[key] = value.en;
    }
  } else if (Array.isArray(value)) {
    // Handle locations array
    resolvedData[key] = value.map(item => {
      if (item.name && typeof item.name === 'object') {
        if (item.name.it) {
          return { ...item, name: item.name.it };
        } else if (item.name.en) {
          return { ...item, name: item.name.en };
        }
      }
      return item;
    });
  }
});
---

<PostLayout {...resolvedData} lang="it">
  {processedMarkdown ? (
    <div set:html={processedMarkdown} />
  ) : (
    <Content />
  )}
</PostLayout>